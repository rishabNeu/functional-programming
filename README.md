# functional-programming
Java 8 Features Snippets 

## :raised_eyebrow: _Functional Interface_
- It contains only one abstract method but can have multiple default and static methods 

- Lambda expression is only applicable to Functional interface
 > Note: ( ) -> { body };   syntax for lambda expression

- You can also use lambda expression to implement compare() method of Comparator interface in a single line when calling 
`Collections.sort(list , (o1,o2) - > return o1.getName().compareTo(o2.getName()));`

 ## :anchor: _Consumer Functional Interface_
- It is an inbuilt interface 
- Used in all contexts where an object is taken as an **input and is to be consumed and some operations are to be performed on it without returning any result**.


 ## :dart: _Predicate Functional Interface_
 - It is used for conditional check
 - If we are using **true/false** returning functions we should use Predicate

- boolean test(T t)


 ## :airplane: _Supplier Functional Interface_
- It is used when there is no input but an output is expected.
- T get();  `T is the object which is the return type of the function.`


```shell 
forEach method accepts Consumer as argument 

filter method accepts predicate as argment based on the condition it filters the data supplied to it.

If you are doing some filtering using filter method and not getting any result then in order to return some dummy result we can use Supplier interface.
```

## :potable_water: _Stream API_
- It is used to process collection of objects.
- Is a sequence of objects that supports various methods which can be pipelined to produce the desired result.
- Why we need streams ?
    - Functional Programming
    - code reduce
    - Bulk operation

## :yarn: Sorting using Stream API & Lambda Expression
```shell
       List<Employee> list =  new Database().getEmployees();
        
       #Traditional method
       Collections.sort(list, new MyComparator());
       System.out.println(list);
       
       #Lambda Expression
       Collections.sort(list ,(o1,o2) -> (int) ((int) o1.getSalary() - o2.getSalary()) );
       System.out.println(list);

       #Stream sorting
       list.stream()
       .sorted((o1,o2) -> (int) ((int) o2.getSalary() - o1.getSalary()))
       .forEach(emp -> System.out.println(emp.getSalary()));
```

## :world_map: Map & Flat Maps
- Both of these are used for **Data transformation**
- Both are `Intermediate` methods & return another Stream as a part of Output.
- Map are just for  **Data**  `Transformation` while FlatMaps are for `Transformation & Flattering.`
 


| map()| flatMap()| 
|----|-----| 
|The function passed to map() operation returns a single value for a single input.	|The function you pass to flatmap() operation returns an arbitrary number of values as the output.|
|One-to-one mapping occurs in map().|One-to-many mapping occurs in flatMap().|
|Only perform the mapping.|Perform mapping as well as flattening.|
|Produce a stream of value.	| Produce a stream of stream value.|
|map() is used only for transformation.	| flatMap() is used both for transformation and mapping. |


```shell
#Example of Stream of Stream (one to many) 
List of list-[[1, 2], [3, 4], [5, 6], [7, 8]]
# The above is converted to Stream using FlatMaps

# Maps is used to do these type of things
List of fruit-[Apple, mango, pineapple, kiwi]
List generated by map-[5, 5, 9, 4]

# Here Map takes list of fruits and converts each (one to one) input to the length of each item which is fruit

```

## :hook: Optional Class
- Suppose if there is an object of student and email is one field.
- And email is ` null ` so when we run the code after creating the object and use the email field then it will throw null pointer exception.
- Hence, to avoid this we can use Optional class and give some default value for ` null `. 
- Like we have options what we want when we use this class as it comes with many predefined methods like **`orElse(), orElseThrow()`**
- It has uses cases with Stream API as well.
- We can throw custom exception as well as an Optional result if the desired result is not there.
 
 
## :point_up: Map-Reduce
- Map is used for data transforming
- Reduce is used for `Aggregating` the transformed data and produce a single output.

```shell
#If you want to find out the average salary of grade A employee :

double averageSalary = employees.stream().
                        .filer((emp) -> emp.getGrade().equals("A"))
                        .map( (emp) -> emp.getSalary())
                        .mapToDouble(i->i)
                        .average().getAsDouble();
System.out.println(averageSalary);
```

## :point_up: Parallel Streams
- It is meant for utilizing the various cores of the processor.
- Any Java code that has only one processing stream, where it is sequentially executed.
- In parallel streams, one can separate the Java code into more than one stream, which is executed in parallel on their separate cores, and the end result is the combination of the individual results
- The order of exection is not under our control.

## :spiral_notepad:  [Java 8 Documentation for Reference](https://docs.oracle.com/javase/8/docs/api/ "Java 8 Doc")

## :artist: _Author_

[Rishab Agarwal](mailto:agarwal.risha@northeastern.edu)



